# The reservation pattern

To safely make stock-related transactions in a highly concurrent environment, we should leave the decision about "do we have enough of this product in stock" to the *Stock* context itself. This requires a bit of a different setup, but we can rely on two important techniques:

1. The Reservation pattern
2. A Process Manager

First, a *reservation* is like a two-step transaction. Given we have a sales order for 2 items of product A.

1. Make a reservation by calling the *Stock* context, asking it to *reserve* 2 items of product A.
2. Wait for a confirmation by means of an event that these items have been reserved, before taking further steps in the process.

At this point the *process manager* comes into play: we need to somehow remember that we've made a reservation and are waiting for a confirmation. We also need to take further steps, based on the outcome of the reservation ("reservation accepted" or "insufficient stock").

Because the process manager has side-effects that shouldn't happen more than once, we can use one of those "consume once" consumers for it. Besides that, it needs to keep state, but we have our convenient `Database` utility for that.

To keep track of the order process and its current state, use the following diagram of state transitions and things that need to be done when an event comes in:

### Event: Sales order created

1. Make a stock reservation (provide product ID and ordered quantity).

### Event: Stock reservation accepted

1. Deliver the sales order.
2. Commit the reservation.

### Event: Stock reservation rejected

1. Do nothing (yet).

Of course, we have to respond to this event too, but let's keep that for the next assignment.

## Step-by-step

Let's first prepare *Stock* to be able to handle reservations. We need a few modifications to the `Balance` model. Take a look at the incomplete tests in `BalanceTest` to find out more about the specifications for this.

If you're done adding the reservation functionality to `Balance`, set up new controllers so you can make HTTP POST call to *Stock* to make and commit stock reservations, i.e. in `StockApplication`, add:

```php
public function makeStockReservationController(): void
{
    
}
``` 

Inside this method, fetch the right `Balance` object from the database, and make the right call (`makeReservation()`) to it, using data from `$_POST` (e.g. `$_POST['reservationId']`, `$_POST['productId']` and `$_POST['quantity']`).

In case the reservation was successful (`makeReservation()` returns `true`), produce an event indicating that the reservation was accepted. As event data, provide the product ID and the reservation ID.

Next, let's create the process manager. As mentioned, this will be a "consume once" consumer, so copy the script one more time from `Common` into `Sales`. Don't forget to define this new consumer in `docker-compose.consumers.yml` too.

The start signal for the process manager is going to be the "sales order created" event. We don't have it yet, so we must produce it first. The data for this event should contain the sales order ID, the product ID and the ordered quantity. While you're working on the `createSalesOrderController()` just remove everything you did for assignment 04 (we're working on a better solution for that problem after all!).

Back to the process manager: when it consumes a "sales order created event", it should make the stock reservation. You can do it with:

```php
HttpApiExtra::postFormData(
    'http://stock_web/makeStockReservation',
    [
        // form data...
    ]
);
```

One simple but important trick here is to use the sales order ID as the reservation ID. That way, when the "reservation accepted" event comes back in, we can relate it to the sales order for which the reservation was made.

Since `makeStockReservationController()` will produce new events informing the process manager about the result of the reservation, it only needs to listen for these events. For now, it should listen to the "reservation accepted" event. If that event comes in, it should deliver the sales order (make an HTTP POST request to `http://sales_web/deliverSalesOrder`, passing in the ID of the sales order that needs to be delivered).

Delivering a sales order will trigger a new event. If the process manager receives that event, it should finally commit the reservation (make an HTTP POST request to `http://stock_web/commitStockReservation`).

Wow! A lot of work, but we've successfully implemented auto-delivery for sales orders. Restart everything, fix possible bugs, and enjoy the result!
